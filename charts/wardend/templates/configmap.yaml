{{- if .Values.node.enabled -}}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-{{ .Values.node.name }}-config
  labels:
    {{- include "node.labels" . | nindent 4 }}
data:
  config.toml: |
    # This is a TOML config file.
    # For more information, see https://github.com/toml-lang/toml

    # NOTE: Any path below can be absolute (e.g. "/var/myawesomeapp/data") or
    # relative to the home directory (e.g. "data"). The home directory is
    # "$HOME/.cometbft" by default, but could be changed via $CMTHOME env variable
    # or --home cmd flag.

    # The version of the CometBFT binary that created or
    # last modified the config file. Do not modify this.
    version = "0.38.12"

    #######################################################################
    ###                   Main Base Config Options                      ###
    #######################################################################

    # TCP or UNIX socket address of the ABCI application,
    # or the name of an ABCI application compiled in with the CometBFT binary
    proxy_app = "tcp://127.0.0.1:26658"

    # A custom human readable name for this node
    moniker = "{{ .Values.node.moniker }}"

    # Database backend: goleveldb | cleveldb | boltdb | rocksdb | badgerdb
    # * goleveldb (github.com/syndtr/goleveldb - most popular implementation)
    #   - pure go
    #   - stable
    # * cleveldb (uses levigo wrapper)
    #   - fast
    #   - requires gcc
    #   - use cleveldb build tag (go build -tags cleveldb)
    # * boltdb (uses etcd's fork of bolt - github.com/etcd-io/bbolt)
    #   - EXPERIMENTAL
    #   - may be faster is some use-cases (random reads - indexer)
    #   - use boltdb build tag (go build -tags boltdb)
    # * rocksdb (uses github.com/tecbot/gorocksdb)
    #   - EXPERIMENTAL
    #   - requires gcc
    #   - use rocksdb build tag (go build -tags rocksdb)
    # * badgerdb (uses github.com/dgraph-io/badger)
    #   - EXPERIMENTAL
    #   - use badgerdb build tag (go build -tags badgerdb)
    db_backend = "goleveldb"

    # Database directory
    db_dir = "data"

    # Output level for logging, including package level options
    log_level = "{{ .Values.node.logLevel }}"

    # Output format: 'plain' (colored text) or 'json'
    log_format = "plain"

    ##### additional base config options #####

    # Path to the JSON file containing the initial validator set and other meta data
    genesis_file = "config/genesis.json"

    # Path to the JSON file containing the private key to use as a validator in the consensus protocol
    priv_validator_key_file = "config/priv_validator_key.json"

    # Path to the JSON file containing the last sign state of a validator
    priv_validator_state_file = "data/priv_validator_state.json"

    # TCP or UNIX socket address for CometBFT to listen on for
    # connections from an external PrivValidator process
    {{- if .Values.node.externalSigner }}
    priv_validator_laddr = "tcp://0.0.0.0:1234"
    {{ else }}
    priv_validator_laddr = ""
    {{- end }}

    # Path to the JSON file containing the private key to use for node authentication in the p2p protocol
    node_key_file = "config/node_key.json"

    # Mechanism to connect to the ABCI application: socket | grpc
    abci = "socket"

    # If true, query the ABCI app on connecting to a new peer
    # so the app can decide if we should keep the connection or not
    filter_peers = false


    #######################################################################
    ###                 Advanced Configuration Options                  ###
    #######################################################################

    #######################################################
    ###       RPC Server Configuration Options          ###
    #######################################################
    [rpc]

    # TCP or UNIX socket address for the RPC server to listen on
    {{- if .Values.node.rpc.enabled }}
    laddr = "tcp://0.0.0.0:26657"
    {{ else }}
    laddr = "tcp://127.0.0.1:26657"
    {{- end }}
    # A list of origins a cross-domain request can be executed from
    # Default value '[]' disables cors support
    # Use '["*"]' to allow any origin
    cors_allowed_origins = []

    # A list of methods the client is allowed to use with cross-domain requests
    cors_allowed_methods = ["HEAD", "GET", "POST", ]

    # A list of non simple headers the client is allowed to use with cross-domain requests
    cors_allowed_headers = ["Origin", "Accept", "Content-Type", "X-Requested-With", "X-Server-Time", ]

    # TCP or UNIX socket address for the gRPC server to listen on
    # NOTE: This server only supports /broadcast_tx_commit
    grpc_laddr = ""

    # Maximum number of simultaneous connections.
    # Does not include RPC (HTTP&WebSocket) connections. See max_open_connections
    # If you want to accept a larger number than the default, make sure
    # you increase your OS limits.
    # 0 - unlimited.
    # Should be < {ulimit -Sn} - {MaxNumInboundPeers} - {MaxNumOutboundPeers} - {N of wal, db and other open files}
    # 1024 - 40 - 10 - 50 = 924 = ~900
    grpc_max_open_connections = 900

    # Activate unsafe RPC commands like /dial_seeds and /unsafe_flush_mempool
    unsafe = false

    # Maximum number of simultaneous connections (including WebSocket).
    # Does not include gRPC connections. See grpc_max_open_connections
    # If you want to accept a larger number than the default, make sure
    # you increase your OS limits.
    # 0 - unlimited.
    # Should be < {ulimit -Sn} - {MaxNumInboundPeers} - {MaxNumOutboundPeers} - {N of wal, db and other open files}
    # 1024 - 40 - 10 - 50 = 924 = ~900
    max_open_connections = 900

    # Maximum number of unique clientIDs that can /subscribe
    # If you're using /broadcast_tx_commit, set to the estimated maximum number
    # of broadcast_tx_commit calls per block.
    max_subscription_clients = 100

    # Maximum number of unique queries a given client can /subscribe to
    # If you're using GRPC (or Local RPC client) and /broadcast_tx_commit, set to
    # the estimated # maximum number of broadcast_tx_commit calls per block.
    max_subscriptions_per_client = 5

    # Experimental parameter to specify the maximum number of events a node will
    # buffer, per subscription, before returning an error and closing the
    # subscription. Must be set to at least 100, but higher values will accommodate
    # higher event throughput rates (and will use more memory).
    experimental_subscription_buffer_size = 200

    # Experimental parameter to specify the maximum number of RPC responses that
    # can be buffered per WebSocket client. If clients cannot read from the
    # WebSocket endpoint fast enough, they will be disconnected, so increasing this
    # parameter may reduce the chances of them being disconnected (but will cause
    # the node to use more memory).
    #
    # Must be at least the same as "experimental_subscription_buffer_size",
    # otherwise connections could be dropped unnecessarily. This value should
    # ideally be somewhat higher than "experimental_subscription_buffer_size" to
    # accommodate non-subscription-related RPC responses.
    experimental_websocket_write_buffer_size = 200

    # If a WebSocket client cannot read fast enough, at present we may
    # silently drop events instead of generating an error or disconnecting the
    # client.
    #
    # Enabling this experimental parameter will cause the WebSocket connection to
    # be closed instead if it cannot read fast enough, allowing for greater
    # predictability in subscription behavior.
    experimental_close_on_slow_client = false

    # How long to wait for a tx to be committed during /broadcast_tx_commit.
    # WARNING: Using a value larger than 10s will result in increasing the
    # global HTTP write timeout, which applies to all connections and endpoints.
    # See https://github.com/tendermint/tendermint/issues/3435
    timeout_broadcast_tx_commit = "10s"

    # Maximum number of requests that can be sent in a batch
    # If the value is set to '0' (zero-value), then no maximum batch size will be
    # enforced for a JSON-RPC batch request.
    max_request_batch_size = 10

    # Maximum size of request body, in bytes
    max_body_bytes = 1000000

    # Maximum size of request header, in bytes
    max_header_bytes = 1048576

    # The path to a file containing certificate that is used to create the HTTPS server.
    # Might be either absolute path or path related to CometBFT's config directory.
    # If the certificate is signed by a certificate authority,
    # the certFile should be the concatenation of the server's certificate, any intermediates,
    # and the CA's certificate.
    # NOTE: both tls_cert_file and tls_key_file must be present for CometBFT to create HTTPS server.
    # Otherwise, HTTP server is run.
    tls_cert_file = ""

    # The path to a file containing matching private key that is used to create the HTTPS server.
    # Might be either absolute path or path related to CometBFT's config directory.
    # NOTE: both tls-cert-file and tls-key-file must be present for CometBFT to create HTTPS server.
    # Otherwise, HTTP server is run.
    tls_key_file = ""

    # pprof listen address (https://golang.org/pkg/net/http/pprof)
    pprof_laddr = "localhost:6060"

    #######################################################
    ###           P2P Configuration Options             ###
    #######################################################
    [p2p]

    # Address to listen for incoming connections
    {{- if .Values.node.p2p.enabled }}
    laddr = "tcp://0.0.0.0:26656"
    {{ else }}
    laddr = "tcp://127.0.0.1:26656"
    {{- end }}

    # Address to advertise to peers for them to dial. If empty, will use the same
    # port as the laddr, and will introspect on the listener to figure out the
    # address. IP and port are required. Example: 159.89.10.97:26656
    external_address = "{{ .Values.node.p2p.externalAddress }}"

    # Comma separated list of seed nodes to connect to
    seeds = "{{.Values.node.p2p.seeds}}"

    # Comma separated list of nodes to keep persistent connections to
    persistent_peers = "{{ .Values.node.p2p.persistentPeers }}"

    # Path to address book
    addr_book_file = "config/addrbook.json"

    # Set true for strict address routability rules
    # Set false for private or local networks
    addr_book_strict = {{ .Values.node.p2p.addrBookStrict }}

    # Maximum number of inbound peers
    max_num_inbound_peers = {{ .Values.node.p2p.maxInboundPeers }}

    # Maximum number of outbound peers to connect to, excluding persistent peers
    max_num_outbound_peers = {{ .Values.node.p2p.maxOutboundPeers }}

    # List of node IDs, to which a connection will be (re)established ignoring any existing limits
    unconditional_peer_ids = ""

    # Maximum pause when redialing a persistent peer (if zero, exponential backoff is used)
    persistent_peers_max_dial_period = "0s"

    # Time to wait before flushing messages out on the connection
    flush_throttle_timeout = "100ms"

    # Maximum size of a message packet payload, in bytes
    max_packet_msg_payload_size = 1024

    # Rate at which packets can be sent, in bytes/second
    send_rate = 5120000

    # Rate at which packets can be received, in bytes/second
    recv_rate = 5120000

    # Set true to enable the peer-exchange reactor
    pex = {{ .Values.node.p2p.pex }}

    # Seed mode, in which node constantly crawls the network and looks for
    # peers. If another node asks it for addresses, it responds and disconnects.
    #
    # Does not work if the peer-exchange reactor is disabled.
    seed_mode = {{ .Values.node.p2p.seedMode }}

    # Comma separated list of peer IDs to keep private (will not be gossiped to other peers)
    private_peer_ids = "{{ .Values.node.p2p.privatePeerIds }}"

    # Toggle to disable guard against peers connecting from the same ip.
    allow_duplicate_ip = false

    # Peer connection configuration.
    handshake_timeout = "20s"
    dial_timeout = "3s"

    #######################################################
    ###          Mempool Configuration Option          ###
    #######################################################
    [mempool]

    # The type of mempool for this node to use.
    #
    #  Possible types:
    #  - "flood" : concurrent linked list mempool with flooding gossip protocol
    #  (default)
    #  - "nop"   : nop-mempool (short for no operation; the ABCI app is responsible
    #  for storing, disseminating and proposing txs). "create_empty_blocks=false" is
    #  not supported.
    type = "{{ .Values.node.mempool.type }}"

    # Recheck (default: true) defines whether CometBFT should recheck the
    # validity for all remaining transaction in the mempool after a block.
    # Since a block affects the application state, some transactions in the
    # mempool may become invalid. If this does not apply to your application,
    # you can disable rechecking.
    recheck = {{ .Values.node.mempool.recheck }}
    
    # recheck_timeout is the time the application has during the rechecking process
    # to return CheckTx responses, once all requests have been sent. Responses that 
    # arrive after the timeout expires are discarded. It only applies to 
    # non-local ABCI clients and when recheck is enabled.
    #
    # The ideal value will strongly depend on the application. It could roughly be estimated as the
    # average size of the mempool multiplied by the average time it takes the application to validate one
    # transaction. We consider that the ABCI application runs in the same location as the CometBFT binary
    # so that the recheck duration is not affected by network delays when making requests and receiving responses.
    recheck_timeout = "{{ .Values.node.mempool.recheckTimeout }}"

    # Broadcast (default: true) defines whether the mempool should relay
    # transactions to other peers. Setting this to false will stop the mempool
    # from relaying transactions to other peers until they are included in a
    # block. In other words, if Broadcast is disabled, only the peer you send
    # the tx to will see it until it is included in a block.
    broadcast = {{ .Values.node.mempool.broadcast }}

    # WalPath (default: "") configures the location of the Write Ahead Log
    # (WAL) for the mempool. The WAL is disabled by default. To enable, set
    # WalPath to where you want the WAL to be written (e.g.
    # "data/mempool.wal").
    wal_dir = ""

    # Maximum number of transactions in the mempool
    size = {{ .Values.node.mempool.size }}

    # Limit the total size of all txs in the mempool.
    # This only accounts for raw transactions (e.g. given 1MB transactions and
    # max_txs_bytes=5MB, mempool will only accept 5 transactions).
    max_txs_bytes = 1073741824

    # Size of the cache (used to filter transactions we saw earlier) in transactions
    cache_size = 10000

    # Do not remove invalid transactions from the cache (default: false)
    # Set to true if it's not possible for any invalid transaction to become valid
    # again in the future.
    keep-invalid-txs-in-cache = false

    # Maximum size of a single transaction.
    # NOTE: the max size of a tx transmitted over the network is {max_tx_bytes}.
    max_tx_bytes = 1048576

    # Maximum size of a batch of transactions to send to a peer
    # Including space needed by encoding (one varint per transaction).
    # XXX: Unused due to https://github.com/tendermint/tendermint/issues/5796
    max_batch_bytes = 0

    # Experimental parameters to limit gossiping txs to up to the specified number of peers.
    # We use two independent upper values for persistent and non-persistent peers.
    # Unconditional peers are not affected by this feature.
    # If we are connected to more than the specified number of persistent peers, only send txs to
    # ExperimentalMaxGossipConnectionsToPersistentPeers of them. If one of those
    # persistent peers disconnects, activate another persistent peer.
    # Similarly for non-persistent peers, with an upper limit of
    # ExperimentalMaxGossipConnectionsToNonPersistentPeers.
    # If set to 0, the feature is disabled for the corresponding group of peers, that is, the
    # number of active connections to that group of peers is not bounded.
    # For non-persistent peers, if enabled, a value of 10 is recommended based on experimental
    # performance results using the default P2P configuration.
    experimental_max_gossip_connections_to_persistent_peers = 0
    experimental_max_gossip_connections_to_non_persistent_peers = 0

    #######################################################
    ###         State Sync Configuration Options        ###
    #######################################################
    [statesync]
    # State sync rapidly bootstraps a new node by discovering, fetching, and restoring a state machine
    # snapshot from peers instead of fetching and replaying historical blocks. Requires some peers in
    # the network to take and serve state machine snapshots. State sync is not attempted if the node
    # has any local state (LastBlockHeight > 0). The node will have a truncated block history,
    # starting from the height of the snapshot.
    enable = {{ .Values.node.statesync.enabled }}

    # RPC servers (comma-separated) for light client verification of the synced state machine and
    # retrieval of state data for node bootstrapping. Also needs a trusted height and corresponding
    # header hash obtained from a trusted source, and a period during which validators can be trusted.
    #
    # For Cosmos SDK-based chains, trust_period should usually be about 2/3 of the unbonding time (~2
    # weeks) during which they can be financially punished (slashed) for misbehavior.
    rpc_servers = "{{ .Values.node.statesync.rpcServers }}"
    trust_height = "{{ .Values.node.statesync.trustHeight }}"
    trust_hash = "{{ .Values.node.statesync.trustHash }}"
    trust_period = "{{ .Values.node.statesync.trustPeriod }}"

    # Time to spend discovering snapshots before initiating a restore.
    discovery_time = "15s"

    # Temporary directory for state sync snapshot chunks, defaults to the OS tempdir (typically /tmp).
    # Will create a new, randomly named directory within, and remove it when done.
    temp_dir = ""

    # The timeout duration before re-requesting a chunk, possibly from a different
    # peer (default: 1 minute).
    chunk_request_timeout = "10s"

    # The number of concurrent chunk fetchers to run (default: 1).
    chunk_fetchers = "4"

    #######################################################
    ###       Block Sync Configuration Options          ###
    #######################################################
    [blocksync]

    # Block Sync version to use:
    #
    # In v0.37, v1 and v2 of the block sync protocols were deprecated.
    # Please use v0 instead.
    #
    #   1) "v0" - the default block sync implementation
    version = "v0"

    #######################################################
    ###         Consensus Configuration Options         ###
    #######################################################
    [consensus]

    wal_file = "data/cs.wal/wal"

    # How long we wait for a proposal block before prevoting nil
    timeout_propose = "3s"
    # How much timeout_propose increases with each round
    timeout_propose_delta = "500ms"
    # How long we wait after receiving +2/3 prevotes for “anything” (ie. not a single block or nil)
    timeout_prevote = "1s"
    # How much the timeout_prevote increases with each round
    timeout_prevote_delta = "500ms"
    # How long we wait after receiving +2/3 precommits for “anything” (ie. not a single block or nil)
    timeout_precommit = "1s"
    # How much the timeout_precommit increases with each round
    timeout_precommit_delta = "500ms"
    # How long we wait after committing a block, before starting on the new
    # height (this gives us a chance to receive some more precommits, even
    # though we already have +2/3).
    timeout_commit = "5s"

    # How many blocks to look back to check existence of the node's consensus votes before joining consensus
    # When non-zero, the node will panic upon restart
    # if the same consensus key was used to sign {double_sign_check_height} last blocks.
    # So, validators should stop the state machine, wait for some blocks, and then restart the state machine to avoid panic.
    double_sign_check_height = 0

    # Make progress as soon as we have all the precommits (as if TimeoutCommit = 0)
    skip_timeout_commit = false

    # EmptyBlocks mode and possible interval between empty blocks
    create_empty_blocks = true
    create_empty_blocks_interval = "0s"

    # Reactor sleep duration parameters
    peer_gossip_sleep_duration = "100ms"
    peer_query_maj23_sleep_duration = "2s"

    #######################################################
    ###         Storage Configuration Options           ###
    #######################################################
    [storage]

    # Set to true to discard ABCI responses from the state store, which can save a
    # considerable amount of disk space. Set to false to ensure ABCI responses are
    # persisted. ABCI responses are required for /block_results RPC queries, and to
    # reindex events in the command-line tool.
    discard_abci_responses = false

    #######################################################
    ###   Transaction Indexer Configuration Options     ###
    #######################################################
    [tx_index]

    # What indexer to use for transactions
    #
    # The application will set which txs to index. In some cases a node operator will be able
    # to decide which txs to index based on configuration set in the application.
    #
    # Options:
    #   1) "null"
    #   2) "kv" (default) - the simplest possible indexer, backed by key-value storage (defaults to levelDB; see DBBackend).
    #               - When "kv" is chosen "tx.height" and "tx.hash" will always be indexed.
    #   3) "psql" - the indexer services backed by PostgreSQL.
    # When "kv" or "psql" is chosen "tx.height" and "tx.hash" will always be indexed.
    indexer = "kv"

    # The PostgreSQL connection configuration, the connection format:
    #   postgresql://<user>:<password>@<host>:<port>/<db>?<opts>
    psql-conn = ""

    #######################################################
    ###       Instrumentation Configuration Options     ###
    #######################################################
    [instrumentation]

    # When true, Prometheus metrics are served under /metrics on
    # PrometheusListenAddr.
    # Check out the documentation for the list of available metrics.
    prometheus = {{ .Values.node.metrics.enabled }}

    # Address to listen for Prometheus collector(s) connections
    prometheus_listen_addr = ":26660"

    # Maximum number of simultaneous connections.
    # If you want to accept a larger number than the default, make sure
    # you increase your OS limits.
    # 0 - unlimited.
    max_open_connections = 3

    # Instrumentation namespace
    namespace = "tendermint"
  app.toml: |
    # This is a TOML config file.
    # For more information, see https://github.com/toml-lang/toml

    ###############################################################################
    ###                           Base Configuration                            ###
    ###############################################################################

    # The minimum gas prices a validator is willing to accept for processing a
    # transaction. A transaction's fees must meet the minimum of any denomination
    # specified in this config (e.g. 0.25token1,0.0001token2).
    minimum-gas-prices = "{{ .Values.node.minGasPrice }}"

    # The maximum gas a query coming over rest/grpc may consume.
    # If this is set to zero, the query can consume an unbounded amount of gas.
    query-gas-limit = "0"

    # default: the last 362880 states are kept, pruning at 10 block intervals
    # nothing: all historic states will be saved, nothing will be deleted (i.e. archiving node)
    # everything: 2 latest states will be kept; pruning at 10 block intervals.
    # custom: allow pruning options to be manually specified through 'pruning-keep-recent', and 'pruning-interval'
    pruning = "{{ .Values.node.pruning.mode }}"

    # These are applied if and only if the pruning strategy is custom.
    pruning-keep-recent = "{{ .Values.node.pruning.pruningKeepRecent }}"
    pruning-interval = "{{ .Values.node.pruning.pruningInterval }}"

    # HaltHeight contains a non-zero block height at which a node will gracefully
    # halt and shutdown that can be used to assist upgrades and testing.
    #
    # Note: Commitment of state will be attempted on the corresponding block.
    halt-height = 0

    # HaltTime contains a non-zero minimum block time (in Unix seconds) at which
    # a node will gracefully halt and shutdown that can be used to assist upgrades
    # and testing.
    #
    # Note: Commitment of state will be attempted on the corresponding block.
    halt-time = 0

    # MinRetainBlocks defines the minimum block height offset from the current
    # block being committed, such that all blocks past this offset are pruned
    # from CometBFT. It is used as part of the process of determining the
    # ResponseCommit.RetainHeight value during ABCI Commit. A value of 0 indicates
    # that no blocks should be pruned.
    #
    # This configuration value is only responsible for pruning CometBFT blocks.
    # It has no bearing on application state pruning which is determined by the
    # "pruning-*" configurations.
    #
    # Note: CometBFT block pruning is dependant on this parameter in conjunction
    # with the unbonding (safety threshold) period, state pruning and state sync
    # snapshot parameters to determine the correct minimum value of
    # ResponseCommit.RetainHeight.
    min-retain-blocks = 0

    # InterBlockCache enables inter-block caching.
    inter-block-cache = true

    # IndexEvents defines the set of events in the form {eventType}.{attributeKey},
    # which informs CometBFT what to index. If empty, all events will be indexed.
    #
    # Example:
    # ["message.sender", "message.recipient"]
    index-events = []

    # IavlCacheSize set the size of the iavl tree cache (in number of nodes).
    iavl-cache-size = 781250

    # IAVLDisableFastNode enables or disables the fast node feature of IAVL.
    # Default is false.
    iavl-disable-fastnode = false

    # AppDBBackend defines the database backend type to use for the application and snapshots DBs.
    # An empty string indicates that a fallback will be used.
    # The fallback is the db_backend value set in CometBFT's config.toml.
    app-db-backend = ""

    ###############################################################################
    ###                         Telemetry Configuration                         ###
    ###############################################################################

    [telemetry]

    # Prefixed with keys to separate services.
    service-name = ""

    # Enabled enables the application telemetry functionality. When enabled,
    # an in-memory sink is also enabled by default. Operators may also enabled
    # other sinks such as Prometheus.
    enabled = {{ .Values.node.metrics.enabled }}

    # Enable prefixing gauge values with hostname.
    enable-hostname = false

    # Enable adding hostname to labels.
    enable-hostname-label = false

    # Enable adding service to labels.
    enable-service-label = false

    # PrometheusRetentionTime, when positive, enables a Prometheus metrics sink.
    prometheus-retention-time = 0

    # GlobalLabels defines a global set of name/value label tuples applied to all
    # metrics emitted using the wrapper functions defined in telemetry package.
    #
    # Example:
    # [["chain_id", "cosmoshub-1"]]
    global-labels = [
    ]

    # MetricsSink defines the type of metrics sink to use.
    metrics-sink = ""

    # StatsdAddr defines the address of a statsd server to send metrics to.
    # Only utilized if MetricsSink is set to "statsd" or "dogstatsd".
    statsd-addr = ""

    # DatadogHostname defines the hostname to use when emitting metrics to
    # Datadog. Only utilized if MetricsSink is set to "dogstatsd".
    datadog-hostname = ""

    ###############################################################################
    ###                           API Configuration                             ###
    ###############################################################################

    [api]

    # Enable defines if the API server should be enabled.
    enable = {{ .Values.node.metrics.enabled }}

    # Swagger defines if swagger documentation should automatically be registered.
    swagger = {{ .Values.node.metrics.enabled }}

    # Address defines the API server to listen on.
    {{- if .Values.node.metrics.enabled }}
    address = "tcp://0.0.0.0:1317"
    {{- else }}
    address = "tcp://localhost:1317"
    {{- end }}

    # MaxOpenConnections defines the number of maximum open connections.
    max-open-connections = 1000

    # RPCReadTimeout defines the CometBFT RPC read timeout (in seconds).
    rpc-read-timeout = 10

    # RPCWriteTimeout defines the CometBFT RPC write timeout (in seconds).
    rpc-write-timeout = 0

    # RPCMaxBodyBytes defines the CometBFT maximum request body (in bytes).
    rpc-max-body-bytes = 1000000

    # EnableUnsafeCORS defines if CORS should be enabled (unsafe - use it at your own risk).
    enabled-unsafe-cors = false

    ###############################################################################
    ###                           gRPC Configuration                            ###
    ###############################################################################

    [grpc]

    # Enable defines if the gRPC server should be enabled.
    enable = {{ .Values.node.grpc.enabled }}

    # Address defines the gRPC server address to bind to.
    {{- if .Values.node.grpc.enabled }}
    address = "0.0.0.0:9090"
    {{- else }}
    address = "localhost:9090"
    {{- end }}

    # MaxRecvMsgSize defines the max message size in bytes the server can receive.
    # The default value is 10MB.
    max-recv-msg-size = "10485760"

    # MaxSendMsgSize defines the max message size in bytes the server can send.
    # The default value is math.MaxInt32.
    max-send-msg-size = "2147483647"

    ###############################################################################
    ###                        gRPC Web Configuration                           ###
    ###############################################################################

    [grpc-web]

    # GRPCWebEnable defines if the gRPC-web should be enabled.
    # NOTE: gRPC must also be enabled, otherwise, this configuration is a no-op.
    # NOTE: gRPC-Web uses the same address as the API server.
    enable = {{ .Values.node.grpc.enabled }}

    ###############################################################################
    ###                        State Sync Configuration                         ###
    ###############################################################################

    # State sync snapshots allow other nodes to rapidly join the network without replaying historical
    # blocks, instead downloading and applying a snapshot of the application state at a given height.
    [state-sync]

    # snapshot-interval specifies the block interval at which local state sync snapshots are
    # taken (0 to disable).
    snapshot-interval = {{ .Values.node.stateSync.snapshotInterval }}

    # snapshot-keep-recent specifies the number of recent snapshots to keep and serve (0 to keep all).
    snapshot-keep-recent = {{ .Values.node.stateSync.snapshotKeepRecent }}

    ###############################################################################
    ###                              State Streaming                            ###
    ###############################################################################

    # Streaming allows nodes to stream state to external systems.
    [streaming]

    # streaming.abci specifies the configuration for the ABCI Listener streaming service.
    [streaming.abci]

    # List of kv store keys to stream out via gRPC.
    # The store key names MUST match the module's StoreKey name.
    #
    # Example:
    # ["acc", "bank", "gov", "staking", "mint"[,...]]
    # ["*"] to expose all keys.
    keys = []

    # The plugin name used for streaming via gRPC.
    # Streaming is only enabled if this is set.
    # Supported plugins: abci
    plugin = ""

    # stop-node-on-err specifies whether to stop the node on message delivery error.
    stop-node-on-err = true

    ###############################################################################
    ###                         Mempool                                         ###
    ###############################################################################

    [mempool]
    # Setting max-txs to 0 will allow for a unbounded amount of transactions in the mempool.
    # Setting max_txs to negative 1 (-1) will disable transactions from being inserted into the mempool.
    # Setting max_txs to a positive number (> 0) will limit the number of transactions in the mempool, by the specified amount.
    #
    # Note, this configuration only applies to SDK built-in app-side mempool
    # implementations.
    max-txs = {{ .Values.node.mempool.maxTxs }}
    ###############################################################################
    ###                                  Oracle                                 ###
    ###############################################################################
    [oracle]

    # Enabled indicates whether the oracle is enabled.
    enabled = {{ .Values.oracle.enabled }}

    # Oracle Address is the URL of the out of process oracle sidecar. This is used to
    # connect to the oracle sidecar when the application boots up. Note that the address
    # can be modified at any point, but will only take effect after the application is
    # restarted. This can be the address of an oracle container running on the same
    # machine or a remote machine.
    oracle_address = "localhost:8080"

    # Client Timeout is the time that the client is willing to wait for responses from
    # the oracle before timing out.
    client_timeout = "2s"

    # MetricsEnabled determines whether oracle metrics are enabled. Specifically
    # this enables instrumentation of the oracle client and the interaction between
    # the oracle and the app.
    metrics_enabled = {{ .Values.oracle.metrics.enabled }}

    # PriceTTL is the maximum age of the latest price response before it is considered stale. 
    # The recommended max age is 10 seconds (10s). If this is greater than 1 minute (1m), the app
    # will not start.
    price_ttl = "{{ .Values.oracle.priceTTL }}"

    # Interval is the time between each price update request. The recommended interval
    # is the block time of the chain. Otherwise, 1.5 seconds (1500ms) is a good default. If this
    # is greater than 1 minute (1m), the app will not start.
    interval = "{{ .Values.oracle.interval }}"

    ###############################################################################
    ###                             EVM Configuration                           ###
    ###############################################################################

    [evm]

    # Tracer defines the 'vm.Tracer' type that the EVM will use when the node is run in
    # debug mode. To enable tracing use the '--evm.tracer' flag when starting your node.
    # Valid types are: json|struct|access_list|markdown
    tracer = ""

    # MaxTxGasWanted defines the gas wanted for each eth tx returned in ante handler in check tx mode.
    max-tx-gas-wanted = 0

    ###############################################################################
    ###                           JSON RPC Configuration                        ###
    ###############################################################################

    [json-rpc]

    # Enable defines if the JSONRPC server should be enabled.
    enable = {{ .Values.evm.rpc }}

    # Address defines the EVM RPC HTTP server address to bind to.
    {{- if .Values.evm.rpc }}
    address = "0.0.0.0:8545"

    # Address defines the EVM WebSocket server address to bind to.
    ws-address = "0.0.0.0:8546"
    {{- else }}
    address = "127.0.0.1:8545"

    # Address defines the EVM WebSocket server address to bind to.
    ws-address = "127.0.0.1:8546"
    {{- end }}
    # API defines a list of JSON-RPC namespaces that should be enabled
    # Example: "eth,txpool,personal,net,debug,web3"
    api = "{{ .Values.evm.api }}"

    # GasCap sets a cap on gas that can be used in eth_call/estimateGas (0=infinite). Default: 25,000,000.
    gas-cap = {{ .Values.evm.gasCap | int }}

    # Allow insecure account unlocking when account-related RPCs are exposed by http
    allow-insecure-unlock = {{ .Values.evm.allowInsecureUnlock }}

    # EVMTimeout is the global timeout for eth_call. Default: 5s.
    evm-timeout = "{{ .Values.evm.evmTimeout }}"

    # TxFeeCap is the global tx-fee cap for send transaction. Default: 1eth.
    txfee-cap = {{ .Values.evm.txfeeCap }}

    # FilterCap sets the global cap for total number of filters that can be created
    filter-cap = {{ .Values.evm.filterCap }}

    # FeeHistoryCap sets the global cap for total number of blocks that can be fetched
    feehistory-cap = {{ .Values.evm.feehistoryCap }}

    # LogsCap defines the max number of results can be returned from single 'eth_getLogs' query.
    logs-cap = {{ .Values.evm.logsCap }}

    # BlockRangeCap defines the max block range allowed for 'eth_getLogs' query.
    block-range-cap = {{ .Values.evm.blockRangeCap }}

    # HTTPTimeout is the read/write timeout of http json-rpc server.
    http-timeout = "{{ .Values.evm.httpTimeout }}"

    # HTTPIdleTimeout is the idle timeout of http json-rpc server.
    http-idle-timeout = "{{ .Values.evm.httpIdleTimeout }}"

    # AllowUnprotectedTxs restricts unprotected (non EIP155 signed) transactions to be submitted via
    # the node's RPC when the global parameter is disabled.
    allow-unprotected-txs = {{ .Values.evm.allowUnprotectedTxs }}

    # MaxOpenConnections sets the maximum number of simultaneous connections
    # for the server listener.
    max-open-connections = {{ .Values.evm.maxOpenConnections }}

    # EnableIndexer enables the custom transaction indexer for the EVM (ethereum transactions).
    enable-indexer = {{ .Values.evm.enableIndexer }}

    # MetricsAddress defines the EVM Metrics server address to bind to. Pass --metrics in CLI to enable
    # Prometheus metrics path: /debug/metrics/prometheus
    {{- if .Values.evm.metrics.enabled }}
    metrics-address = "0.0.0.0:6065"
    {{- else }}
    metrics-address = "127.0.0.1:6065"
    {{- end }}

    # Upgrade height for fix of revert gas refund logic when transaction reverted.
    fix-revert-gas-refund-height = 0

    ###############################################################################
    ###                             TLS Configuration                           ###
    ###############################################################################

    [tls]

    # Certificate path defines the cert.pem file path for the TLS configuration.
    certificate-path = ""

    # Key path defines the key.pem file path for the TLS configuration.
    key-path = ""

    ###############################################################################
    ###                      Price prediction configuration                     ###
    ###############################################################################
    [pricepred]

    # Is price prediction enabled
    enabled = {{ .Values.pricepred.enabled }}

    # URL used for price prediction handler
    url = "{{ .Values.pricepred.url }}"

{{- end }}
